```html
<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <title>Local Player</title>
    <style>
        html, body {
            margin: 0;
            padding: 0;
            height: 100%;
            width: 100%;
            background: #000;
            overflow: hidden;
            font-family: Segoe UI, Arial, sans-serif;
        }

        #player {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        .info {
            position: absolute;
            bottom: 30px;
            left: 30px;
            color: #fff;
            text-shadow: 0 0 8px rgba(0,0,0,0.7);
            font-size: 20px;
            z-index: 10;
        }

        #title {
            font-weight: bold;
            font-size: 24px;
        }

        #requested {
            font-size: 16px;
            opacity: 0.8;
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/microsoft-signalr/7.0.5/signalr.min.js"></script>
    <script src="https://www.youtube.com/iframe_api"></script>
</head>
<body>
    <div id="player"></div>
    <div class="info">
        <div id="title">—</div>
        <div id="requested">—</div>
    </div>

    <script>
        let connection = new signalR.HubConnectionBuilder()
            .withUrl("/hub/player")
            .build();

        let ytPlayer = null;

        connection.on("LoadTrack", async obj => {
            if (obj && obj.videoId) await loadVideo(obj);
        });

        connection.on("SetVolume", value => {
            if (ytPlayer && typeof ytPlayer.setVolume === "function") {
                ytPlayer.setVolume(value);
            }
        });

        connection.on("NewTrackNotify", async obj => {
            if (!ytPlayer || ytPlayer.getPlayerState() !== YT.PlayerState.PLAYING) {
                await loadVideo(obj);
            }
        });

        connection.on("SkipTrack", () => {
            if (ytPlayer && typeof ytPlayer.getDuration === "function") {
                const duration = ytPlayer.getDuration();
                ytPlayer.seekTo(duration, true);
            }
        });


        connection.on("PlayPauseVideo", () => {
            togglePlayPause();
        });

        async function start() {
            await connection.start();
            const now = await connection.invoke("GetNow");
            if (now && now.videoId) {
                await loadVideo(now);
            } else {
                const next = await connection.invoke("GetNext");
                if (next && next.videoId) await loadVideo(next);
            }
        }

        async function loadVideo(obj) {
            if (!obj || !obj.videoId) {
                document.getElementById('title').innerText = 'Нет трека';
                document.getElementById('requested').innerText = '';
                if (ytPlayer) ytPlayer.stopVideo();
                return;
            }

            document.getElementById('title').innerText = obj.title || obj.videoId;
            document.getElementById('requested').innerText = 'Requested by: ' + (obj.ownerName || '—');

            if (!ytPlayer) {
                ytPlayer = new YT.Player('player', {
                    width: '100%',
                    height: '100%',
                    videoId: obj.videoId,
                    playerVars: {
                        autoplay: 1,       // автозапуск
                        controls: 0,       // убрать кнопки
                        modestbranding: 1, // убрать логотип
                        rel: 0,            // не показывать похожие
                        fs: 0,             // убрать fullscreen
                        iv_load_policy: 3, // убрать аннотации
                    },
                    events: {
                        'onStateChange': onPlayerStateChange
                    }
                });
            await applyInitialVolume();
            } else {
                ytPlayer.loadVideoById({ videoId: obj.videoId, startSeconds: 0, suggestedQuality: "default" });
            }
        }

        async function onPlayerStateChange(event) {
            if (event.data === YT.PlayerState.ENDED) {
                const next = await connection.invoke("GetNext");
                if (next && next.videoId) await loadVideo(next);
            }

        }
        async function applyInitialVolume() {
            const volume = await connection.invoke("GetVolume");
            if (ytPlayer && typeof ytPlayer.setVolume === "function") {
                ytPlayer.setVolume(volume);
            }
        }

        function togglePlayPause() {
            if (!ytPlayer) return;
            const state = ytPlayer.getPlayerState();
            if (state === YT.PlayerState.PLAYING) ytPlayer.pauseVideo();
            else ytPlayer.playVideo();
        }

        start();
    </script>
</body>
</html>
```
